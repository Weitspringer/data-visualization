    <!DOCTYPE html>
    <html lang="eng">
    <head>
    <meta charset="UTF-8" />
    <title>Interactive Parallel Coordinates Plot</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
        text, .form {
        font-family: "Ubuntu", sans-serif;
        font-size: 7pt;
        }
        .title {
        font-family: "Ubuntu", sans-serif;
        font-size: 20pt;
        font-weight: 300;
        }
    </style>
    </head>
    <body>
    <div id="chart"></div>
        <p>
        <label
            for="filter-attribute"
            style="display: inline-block; width: 240px; text-align: right"
        >
        Select attribute: <span id="filter-attribute-value"></span>
        </label>
        <select id="filter-attribute">
        </select>
        </p>
        <p id="min-cont" style="visibility: hidden;">
        <label
            for="filter-min"
            style="display: inline-block; width: 240px; text-align: right"
        >
            Min: <span id="filter-min-value"></span>
        </label>
        <input id="filter-min" type="range" step="any">
        </p>
        <p id="max-cont" style="visibility: hidden;">
        <label
            for="filter-max"
            style="display: inline-block; width: 240px; text-align: right"
        >
            Max: <span id="filter-max-value"></span>
        </label>
        <input id="filter-max" type="range" step="any">
        </p>
    </body>
    <script>
    // Dimensions with margins
    var margin = { top: 40, right: 20, bottom: 50, left: 0 },
        width = 1200 - margin.left - margin.right,
        height = 500 - margin.top - margin.bottom;

    // Insert svg and group
    var svg = d3
        .select("#chart")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    // Read csv data
    d3.csv("/data/Wine.csv", function (row) {
        return row;
    }).then(function (data) {
        draw(data);
    });

    // Draw the data
    function draw(data) {
        // Extract the list of dimensions
        dimensions = d3.keys(data[0]).filter((d) => d != "" && d != "target");

        qualities = [0.0, 1.0, 2.0];

        // Create color scheme for quality
        var color = d3.scaleOrdinal().domain(qualities).range(d3.schemeSet2);

        // Linear scale for each dimension
        var y = {};
        for (i in dimensions) {
        dimension = dimensions[i];
        y[dimension] = d3
            .scaleLinear()
            .domain(
            d3.extent(data, function (d) {
                return +d[dimension];
            })
            )
            .range([height, margin.top]);
        }

        // Build the X scale -> it find the best position for each Y axis
        x = d3
        .scalePoint()
        .range([0, width - margin.right])
        .padding(1)
        .domain(dimensions);

        // Row as input, return x and y coordinates of the line
        function path(d) {
        return d3.line()(
            dimensions.map(function (dimension) {
            return [x(dimension), y[dimension](d[dimension])];
            })
        );
        }

        // Draw the lines as path elements
        svg
        .selectAll("myPath")
        .data(data)
        .enter()
        .append("path")
        .attr("d", path)
        .style("fill", "none")
        .style("stroke", (d) => color(parseFloat(d.target)))
        .style("opacity", 0.7);

        // Draw the axis:
        svg
        .selectAll("myAxis")
        // For each dimension of the dataset I add a 'g' element:
        .data(dimensions)
        .enter()
        .append("g")
        // Translate to correct position on the x axis
        .attr("transform", function (d) {
            return "translate(" + x(d) + ")";
        })
        .each(function (d) {
            d3.select(this).call(d3.axisLeft().scale(y[d]));
        })
        // Label axis
        .append("text")
        .style("text-anchor", "middle")
        .attr("y", margin.top - 5)
        .text(function (d) {
            return d;
        })
        .style("fill", "black");

        // Add legend
        var size = 20;
        svg
        .append("text")
        .attr("x", width - 50)
        .attr("y", margin.top - 5)
        .text("Quality class");
        svg
        .selectAll("myrect")
        .data(qualities)
        .enter()
        .append("rect")
        .attr("x", width - 50)
        .attr("y", function (d, i) {
            return margin.top + i * (size + 5);
        })
        .attr("width", size)
        .attr("height", size)
        .style("fill", (d) => color(d));
        svg
        .selectAll("mylabels")
        .data(qualities)
        .enter()
        .append("text")
        .attr("x", width - 50 + size * 1.2)
        .attr("y", function (d, i) {
            return margin.top + i * (size + 5) + (3 * size) / 4;
        })
        .style("fill", (d) => color(d))
        .text((d) => d)
        .attr("text-anchor", "left")
        .style("alignment-baseline", "middle");

        // when the input range changes update the circle 
        d3.select("#form-").on("input", function() {
        update(+this.value);
        });

        // Set up dimensions for filter
        filter_dimensions = ["none"].concat(dimensions);
        // Add dimensions to dropdown menu
        const select  = d3.select("#filter-attribute").on("change", updateFilterInterface),
        options = select.selectAll('option').data(filter_dimensions).enter().append("option").text((d) => d);

        // Define min and max sliders
        const min = d3.select("#filter-min");
        const max = d3.select("#filter-max");
        d3.select("#filter-min").on("input", function() {
            val = +this.value;
            if (val > max.property("value")) {
                this.value = +max.property("value");
                val = +max.property("value");
            }
            d3.select("#filter-min-value").text(val.toFixed(2));
        });
        d3.select("#filter-max").on("input", function() {
            val = +this.value;
            if (val < min.property("value")) {
                this.value = min.property("value");
                val = +min.property("value");
            }
            d3.select("#filter-max-value").text(val.toFixed(2));
        });

        // If dimension from dropdown menu is selected, adjust sliders or reset filter view if "none" is selected
        function updateFilterInterface() {
            dimension = select.property("value")
            if (dimension != "none") {
                scale = y[dimension];
                domain = d3.extent(data, (d) => +d[dimension]);
                d3.select("#filter-min").property("min", domain[0]).property("max", domain[1]).property("value", domain[0]);
                d3.select("#filter-min-value").text(domain[0].toFixed(2));
                d3.select("#filter-max").property("min", domain[0]).property("max", domain[1]).property("value", domain[1]);
                d3.select("#filter-max-value").text(domain[1].toFixed(2));
                // Make sliders visible
                d3.select("#min-cont").style("visibility", "visible");
                d3.select("#max-cont").style("visibility", "visible");
            } else {
                // Reset the filter
                reset();
            }
        }

        function reset() {
            // Hide sliders
            d3.select("#min-cont").style("visibility", "hidden");
            d3.select("#max-cont").style("visibility", "hidden");
        }
    }
    </script>
    </html>
