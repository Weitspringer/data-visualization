<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Brush functionality</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style>
      text {
        font-family: "Yanone Kaffeesatz", sans-serif;
        font-size: 7pt;
      }
      .domain {
        opacity: 0;
      }
      .y-axis line,
      .x-axis line {
        stroke-width: 0.25;
        stroke: rgba(114, 138, 74, 0.5);
      }
      .label {
        font-size: 9pt;
        text-anchor: middle;
      }
    </style>
  </head>
  <body>
    <svg width="100%" height="100%" viewBox="0 0 500 300"></svg>
  </body>
  <script>
    const w = 500,
      h = 300,
      marginH = 40,
      marginW = 50,
      circMin = 1,
      circMax = 6;

    var maxPop = 0;
    var minPop = Number.MAX_SAFE_INTEGER;
    var initialXDomain, initialYDomain;

    const scaleX = d3.scaleLinear().range([marginW, w - marginW]);
    const scaleY = d3.scaleLog().range([h - marginH, marginH]);
    const color = d3.scaleOrdinal(d3.schemeDark2);

    const axisX = d3
      .axisBottom(scaleX)
      .tickSize(h - marginH * 2 + 10)
      .tickPadding(2);
    const axisY = d3
      .axisLeft(scaleY)
      .tickSize(w - marginW * 2 + 10)
      .tickPadding(2)
      .ticks(8, ",");

    const data = {
      continents: new Set(),
    };

    d3.csv("/exercise_2_1/data/UnRegionsGdp.csv", function (row) {
      if (row.HDI_2017 > 0 && row.GDP_2017 > 0) {
        data.continents.add(row.Continent);
        maxPop = +row.Pop_2016 > maxPop ? +row.Pop_2016 : maxPop;
        minPop = +row.Pop_2016 < minPop ? +row.Pop_2016 : minPop;
        return {
          name: row.Country,
          code: row.Code,
          continent: row.Continent,
          population: +row.Pop_2016,
          hdi: +row.HDI_2017,
          gdp: +row.GDP_2017,
        };
      }
    }).then(function (dataset) {
      data.continents = [...data.continents].sort((a, b) => d3.ascending(a, b));
      data.countries = dataset;
      initialYDomain = d3.extent(dataset, (d) => d.gdp);
      initialXDomain = d3.extent(dataset, (d) => d.hdi);
      scaleY.domain(initialYDomain);
      scaleX.domain(initialXDomain);

      draw();
      drawLegend();
    });

    function draw() {
      const scaleRadius = d3
        .scaleSqrt()
        .domain([minPop, maxPop])
        .range([circMin, circMax]);

      const xG = d3
        .select("svg")
        .append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(${[0, marginH]})`)
        .call(axisX);

      const yG = d3
        .select("svg")
        .append("g")
        .attr("class", "y-axis")
        .attr("transform", `translate(${[w - marginW, 0]})`)
        .call(axisY);

      d3.select("svg")
        .append("text")
        .attr("class", "label")
        .text("Human Development Index (HDI)")
        .attr("transform", `translate(${[w / 2, h - 3]})`);
      d3.select("svg")
        .append("text")
        .attr("class", "label")
        .text("Annual GDP per capita (USD)")
        .attr("transform", `translate(${[3, h / 2]}) rotate(90)`);

        var clip = d3
        .select("svg")
        .append("defs")
        .append("svg:clipPath")
        .attr("id", "clip")
        .append("svg:rect")
        .attr("width", w - 87)
        .attr("height", h - 65)
        .attr("x", 40)
        .attr("y", 37);

      var scatter = d3
        .select("svg")
        .append("g")
        .attr("clip-path", "url(#clip)");

      scatter
        .selectAll("circle")
        .data(data.countries)
        .enter()
        .append("circle")
        .attr("r", (d) => scaleRadius(d.population))
        .attr("cx", (d) => scaleX(d.hdi))
        .attr("cy", (d) => scaleY(d.gdp))
        .style("fill", (d) => color(d.continent));

      var brush = d3
        .brushX()
        .extent([
          [40, 35],
          [w - 45, h - 35],
        ])
        .on("end", updateScatterPlot);

      scatter.append("g").attr("class", "brush").call(brush);

      var idleTimeout;
      function idled() {
        idleTimeout = null;
      }

      function updateScatterPlot() {
        extent = d3.event.selection;

        if (!extent) {
          if (!idleTimeout) return (idleTimeout = setTimeout(idled, 350));
          scaleX.domain(initialXDomain);
        } else {
          scaleX.domain([scaleX.invert(extent[0]), scaleX.invert(extent[1])]);
          scatter.select(".brush").call(brush.move, null);
        }

        // Update axis
        const axisX = d3
          .axisBottom(scaleX)
          .tickSize(h - marginH * 2 + 10)
          .tickPadding(2);

        xG.transition().duration(1000).call(axisX);

        d3.select("svg")
          .selectAll("circle")
          .transition()
          .duration(1000)
          .attr("cx", (d) => scaleX(d.hdi))
          .attr("cy", (d) => scaleY(d.gdp));
      }
    }

    function drawLegend() {
      const legend = d3
        .select("svg")
        .append("g")
        .attr("class", "legend")
        .attr("transform", `translate(${[85, 50]})`);

      legend
        .selectAll("g.item")
        .data(data.continents)
        .join("g")
        .attr("class", "item")
        .each(function (d, i) {
          d3.select(this)
            .append("rect")
            .attr("y", i * 10)
            .attr("height", 8)
            .attr("width", 20)
            .style("fill", color(d));

          d3.select(this)
            .append("text")
            .attr("y", i * 10 + 7)
            .attr("x", 24)
            .text(d);
        });
    }
  </script>
</html>
